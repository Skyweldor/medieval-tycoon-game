<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ğŸ° Medieval Tycoon - With Real Assets</title>

  <!-- External CSS (Phase 0 refactoring) -->
  <link rel="stylesheet" href="styles/main.css">
  <link rel="stylesheet" href="styles/layout.css">
  <link rel="stylesheet" href="styles/components.css">
  <link rel="stylesheet" href="styles/game-world.css">
  <link rel="stylesheet" href="styles/merchant.css">
  <link rel="stylesheet" href="styles/animations.css">

  <!-- Module entry point (loads config and sets up globals) -->
  <script type="module" src="src/main.js"></script>

</head>
<body>
  <div class="game-container">
    <!-- Header -->
    <div class="header">
      <h1>ğŸ° Medieval Tycoon</h1>
      <p>Build your village, harvest resources, grow your empire!</p>
    </div>
    
    <!-- Resource Bar -->
    <div class="resource-bar">
      <div class="resource">
        <span class="resource-icon">ğŸ’°</span>
        <div class="resource-info">
          <span class="resource-name">Gold</span>
          <span class="resource-value" id="gold-value">50</span>
          <span class="resource-rate neutral" id="gold-rate">+0/s</span>
        </div>
      </div>
      <div class="resource">
        <span class="resource-icon">ğŸŒ¾</span>
        <div class="resource-info">
          <span class="resource-name">Wheat</span>
          <span class="resource-value" id="wheat-value">0</span>
          <span class="resource-rate neutral" id="wheat-rate">+0/s</span>
        </div>
      </div>
      <div class="resource">
        <span class="resource-icon">â›ï¸</span>
        <div class="resource-info">
          <span class="resource-name">Stone</span>
          <span class="resource-value" id="stone-value">0</span>
          <span class="resource-rate neutral" id="stone-rate">+0/s</span>
        </div>
      </div>
      <div class="resource">
        <span class="resource-icon">ğŸŒ²</span>
        <div class="resource-info">
          <span class="resource-name">Wood</span>
          <span class="resource-value" id="wood-value">0</span>
          <span class="resource-rate neutral" id="wood-rate">+0/s</span>
        </div>
      </div>
      <!-- Royal Stipend Indicator -->
      <div class="stipend-indicator" id="stipend-indicator">
        <span>ğŸ‘‘</span>
        <span>Royal Stipend: +1ğŸ’°/2s</span>
      </div>
    </div>
    
    <!-- Main 3-Column Layout -->
    <div class="main-layout">
      <!-- Left Panel - Tabbed (Inspect / Build) -->
      <div class="left-panel">
        <div class="left-tabbed-panel">
          <div class="tab-buttons">
            <button class="tab-btn active" onclick="switchLeftTab('inspect')" title="Inspect">ğŸ”</button>
            <button class="tab-btn" onclick="switchLeftTab('build')" title="Build">ğŸ”¨</button>
          </div>

          <!-- Inspect Tab -->
          <div class="tab-content active" id="left-tab-inspect">
            <div class="building-info-empty" id="building-info-empty">
              ğŸ  Hover over a building to see its details
            </div>
            <div class="building-info-content" id="building-info-content" style="display: none;">
              <div class="building-info-header">
                <span class="building-info-icon" id="info-icon">ğŸŒ¾</span>
                <div class="building-info-title">
                  <h3 id="info-name">Building Name</h3>
                  <span class="level-text" id="info-level">Level 1</span>
                </div>
              </div>
              <div class="building-info-stats">
                <div class="info-stat-row">
                  <span class="info-stat-label">Status</span>
                  <span class="info-stat-value" id="info-status">Active</span>
                </div>
                <div class="info-stat-row" id="info-upgrade-row">
                  <span class="info-stat-label">Upgrade Cost</span>
                  <span class="info-stat-value" id="info-upgrade-cost">100 ğŸ’°</span>
                </div>
              </div>
              <div class="info-production">
                <div class="info-production-title">Production (per second)</div>
                <div id="info-production-list">
                  <!-- Generated by JS -->
                </div>
              </div>
            </div>
          </div>

          <!-- Build Tab -->
          <div class="tab-content" id="left-tab-build">
            <div class="build-tab-header">
              Select a building to place:
            </div>
            <div class="build-list" id="build-list">
              <!-- Generated by JS -->
            </div>
            <div class="build-cancel" id="build-cancel" style="display: none;">
              <button class="btn btn-reset" onclick="cancelPlacement()">âŒ Cancel</button>
            </div>
          </div>
        </div>
      </div>

      <!-- Center Content -->
      <div class="center-content">
        <!-- Game World -->
        <div class="game-world" id="game-world">
          <!-- In-Canvas Resource Overlay -->
          <div class="resource-overlay" id="resource-overlay">
            <div class="resource-overlay-item">
              <span class="resource-overlay-icon">ğŸ’°</span>
              <span class="resource-overlay-value" id="overlay-gold-value">50</span>
              <span class="resource-overlay-rate neutral" id="overlay-gold-rate">+0/s</span>
            </div>
            <div class="resource-overlay-item">
              <span class="resource-overlay-icon">ğŸŒ¾</span>
              <span class="resource-overlay-value" id="overlay-wheat-value">0</span>
              <span class="resource-overlay-rate neutral" id="overlay-wheat-rate">+0/s</span>
            </div>
            <div class="resource-overlay-item">
              <span class="resource-overlay-icon">â›ï¸</span>
              <span class="resource-overlay-value" id="overlay-stone-value">0</span>
              <span class="resource-overlay-rate neutral" id="overlay-stone-rate">+0/s</span>
            </div>
            <div class="resource-overlay-item">
              <span class="resource-overlay-icon">ğŸŒ²</span>
              <span class="resource-overlay-value" id="overlay-wood-value">0</span>
              <span class="resource-overlay-rate neutral" id="overlay-wood-rate">+0/s</span>
            </div>
          </div>
          <div class="debug-grid"></div>
          <div class="ground-layer"></div>
          <div class="highlight-layer"></div>
          <!-- Buildings will be inserted here by JavaScript -->
        </div>

        <!-- Stats -->
        <div class="stats-panel">
          <div class="stat-box">
            <div class="stat-label">Buildings</div>
            <div class="stat-value" id="stat-buildings">0/9</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Total Levels</div>
            <div class="stat-value" id="stat-levels">0</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Net Worth</div>
            <div class="stat-value" id="stat-worth">50</div>
          </div>
        </div>

        <!-- Buttons -->
        <div class="button-row">
          <button class="btn btn-reset" onclick="resetGame()">ğŸ”„ Reset</button>
          <button class="btn btn-reset" onclick="toggleTiles()" id="toggle-tiles-btn">ğŸ™ˆ Tiles</button>
          <button class="btn btn-reset" onclick="toggleDebugSliders()" id="toggle-sliders-btn">ğŸ”§ Offsets</button>
          <button class="btn btn-reset" onclick="toggleDarkMode()" id="toggle-dark-btn">ğŸŒ™ Dark</button>
        </div>

        <!-- Debug Sliders (hidden by default) -->
        <div class="debug-sliders" id="debug-sliders" style="display: none;">
          <div style="font-size: 10px; color: #aaa; margin-bottom: 5px;">Building Offsets:</div>
          <div class="slider-group">
            <label>X Offset: <span id="x-offset-value">2</span>px</label>
            <input type="range" id="x-offset-slider" min="-50" max="50" value="2" step="1">
          </div>
          <div class="slider-group">
            <label>Y Offset: <span id="y-offset-value">-8</span>px</label>
            <input type="range" id="y-offset-slider" min="-50" max="50" value="-8" step="1">
          </div>
          <div class="slider-group">
            <label>Size Mult: <span id="size-mult-value">2.0</span></label>
            <input type="range" id="size-mult-slider" min="1.0" max="3.0" value="2.0" step="0.1">
          </div>
          <div style="font-size: 10px; color: #aaa; margin: 8px 0 5px;">Cursor Offsets:</div>
          <div class="slider-group">
            <label>Cursor X: <span id="cursor-x-value">-1</span>px</label>
            <input type="range" id="cursor-x-slider" min="-50" max="50" value="-1" step="1">
          </div>
          <div class="slider-group">
            <label>Cursor Y: <span id="cursor-y-value">-1</span>px</label>
            <input type="range" id="cursor-y-slider" min="-50" max="50" value="-1" step="1">
          </div>
          <button class="btn btn-reset" onclick="copyDebugValues()">ğŸ“‹ Copy Values</button>
        </div>
      </div>

      <!-- Right Panel - Tabbed Interface -->
      <div class="right-panel">
        <div class="tabbed-panel">
          <div class="tab-buttons">
            <button class="tab-btn active" onclick="switchTab('milestones')">ğŸ“œ Milestones</button>
            <button class="tab-btn" onclick="switchTab('market')">ğŸª Market</button>
          </div>

          <!-- Milestones Tab -->
          <div class="tab-content active" id="tab-milestones">
            <div class="milestone-progress-header">
              <span>Progress: </span>
              <span id="milestone-progress">0/8</span>
            </div>
            <div class="milestone-list" id="milestone-list">
              <!-- Generated by JS -->
            </div>
          </div>

          <!-- Market Tab -->
          <div class="tab-content" id="tab-market">
            <div class="market-status" id="market-status">
              <div class="market-locked">
                ğŸ”’ Build a Market to unlock trading
              </div>
            </div>
            <div class="market-trading-content" id="market-trading-content" style="display: none;">
              <div class="market-level-display">
                <span>Market Level: </span>
                <span id="market-level">1</span>
              </div>
              <div class="market-trades" id="market-trades">
                <!-- Generated by JS -->
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Notifications Container -->
  <div class="notifications" id="notifications"></div>

  <!-- Merchant Banner -->
  <div class="merchant-banner" id="merchant-banner">
    <div class="merchant-avatar">ğŸ§³</div>
    <div class="merchant-info">
      <div class="merchant-title">Traveling Merchant</div>
      <div class="merchant-timer">Leaving in <span id="merchant-countdown">30</span>s</div>
    </div>
    <button class="merchant-trade-btn" onclick="openMerchantPanel()">Trade</button>
  </div>

  <!-- Merchant Trading Overlay -->
  <div class="merchant-overlay" id="merchant-overlay" onclick="closeMerchantPanel()">
    <div class="merchant-panel" onclick="event.stopPropagation()">
      <div class="merchant-header">
        <span class="merchant-face">ğŸ§”</span>
        <div class="merchant-header-info">
          <h3>Traveling Merchant</h3>
          <p class="merchant-dialogue" id="merchant-dialogue">"What would you like to sell today?"</p>
        </div>
        <div class="merchant-timer-badge">
          <span id="merchant-panel-countdown">30</span>s
        </div>
      </div>

      <div class="trade-rows" id="merchant-trade-rows">
        <!-- Generated by JS -->
      </div>

      <div class="merchant-footer">
        <span class="merchant-tip">ğŸ’¡ Build a Market for better prices!</span>
        <button class="btn-close" onclick="closeMerchantPanel()">Close</button>
      </div>
    </div>
  </div>

  <script>
    // ==========================================
    // TILE GRID CONFIGURATION
    // Generated by Tile Calibrator
    // ==========================================
    // Scale factor to fit tiles in game world (adjust to zoom in/out)
    const TILE_SCALE = 0.35;

    const TILE_CONFIG = {
      // Full tile dimensions (including depth edge) - scaled
      tileWidth: 183 * TILE_SCALE,
      tileHeight: 191 * TILE_SCALE,

      // Grid diamond dimensions (flat top face only) - scaled
      gridWidth: 183 * TILE_SCALE,
      gridHeight: 113 * TILE_SCALE,

      // Depth edge (3D effect) - scaled
      depthHeight: 78 * TILE_SCALE,

      // Grid offset (if tile isn't centered) - scaled
      gridOffsetY: -47 * TILE_SCALE,

      // Grid size
      cols: 10,
      rows: 10,
    };

    // Tile type constants
    const TILE = {
      GRASS: 0,
      COBBLE: 1,
      DIRT: 2,
    };

    // Map array: 0=grass, 1=cobble, 2=dirt
    // Layout: 10 cols Ã— 10 rows isometric grid
    const TILE_MAP = [
      //0  1  2  3  4  5  6  7  8  9
      [ 0, 0, 0, 0, 1, 1, 0, 0, 0, 0 ],  // Row 0
      [ 0, 0, 0, 1, 1, 1, 1, 0, 0, 0 ],  // Row 1
      [ 0, 0, 1, 1, 1, 1, 1, 1, 0, 0 ],  // Row 2
      [ 0, 1, 1, 1, 1, 1, 1, 1, 1, 0 ],  // Row 3
      [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ],  // Row 4 - center
      [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ],  // Row 5 - center
      [ 0, 1, 1, 1, 1, 1, 1, 1, 1, 0 ],  // Row 6
      [ 0, 0, 1, 1, 1, 1, 1, 1, 0, 0 ],  // Row 7
      [ 0, 0, 0, 1, 1, 1, 1, 0, 0, 0 ],  // Row 8
      [ 0, 0, 0, 0, 1, 1, 0, 0, 0, 0 ],  // Row 9
    ];

    // ==========================================
    // ASSET CONFIGURATION
    // ==========================================
    // Update these paths to point to your asset files
    const ASSETS = {
      // Ground tiles
      ground: 'assets/ground_basic.png',
      cobble: 'assets/cobble_basic.png',
      dirt: 'assets/dirt_basic.png',
      
      // Buildings - organized by type and level
      wheat_farm: {
        1: 'assets/wheat_basic_young.png',
        2: 'assets/wheat_basic_young.png', // Replace with lv2 when ready
        3: 'assets/wheat_basic_young.png', // Replace with lv3 when ready
        4: 'assets/wheat_basic_young.png', // Replace with lv4 when ready
      },
      quarry: {
        1: 'assets/quarry_basic.png',
        2: 'assets/quarry_basic.png',
        3: 'assets/quarry_basic.png',
        4: 'assets/quarry_basic.png',
      },
      lumber: {
        1: 'assets/lumber_basic.png',
        2: 'assets/lumber_basic.png',
        3: 'assets/lumber_basic.png',
        4: 'assets/lumber_basic.png',
      },
      bakery: {
        1: 'assets/bakery_basic.png',
        2: 'assets/bakery_basic.png',
        3: 'assets/bakery_basic.png',
        4: 'assets/bakery_basic.png',
      },
      blacksmith: {
        1: 'assets/blacksmith_basic.png',
        2: 'assets/blacksmith_basic.png',
        3: 'assets/blacksmith_basic.png',
        4: 'assets/blacksmith_basic.png',
      },
      market: {
        1: 'assets/market_basic.png',
        2: 'assets/market_basic.png',
        3: 'assets/market_basic.png',
        4: 'assets/market_basic.png',
      },
      townhall: {
        1: 'assets/town_hall_basic.png',
        2: 'assets/town_hall_basic.png',
        3: 'assets/town_hall_basic.png',
      },
      barn: {
        1: 'assets/barn_basic.png',
        2: 'assets/barn_basic.png',
        3: 'assets/barn_basic.png',
      },
    };
    
    // Fallback emojis when assets aren't available
    const EMOJI_FALLBACKS = {
      wheat_farm: 'ğŸŒ¾',
      quarry: 'â›ï¸',
      lumber: 'ğŸª“',
      bakery: 'ğŸ¥–',
      blacksmith: 'âš’ï¸',
      market: 'ğŸª',
      townhall: 'ğŸ›ï¸',
      barn: 'ğŸšï¸',
    };

    // ==========================================
    // GAME CONFIGURATION
    // ==========================================
    const BUILDINGS = {
      wheat_farm: {
        name: 'Wheat Farm',
        baseCost: { gold: 10 },
        production: { wheat: 1 },
        upgrades: [
          { cost: { gold: 50 }, mult: 2 },
          { cost: { gold: 200 }, mult: 3 },
          { cost: { gold: 800 }, mult: 5 },
        ],
        unlockReq: null,
      },
      quarry: {
        name: 'Stone Quarry',
        baseCost: { gold: 25 },
        production: { stone: 1 },
        upgrades: [
          { cost: { gold: 100 }, mult: 2 },
          { cost: { gold: 400 }, mult: 3 },
          { cost: { gold: 1500 }, mult: 5 },
        ],
        unlockReq: { wheat: 10 },
      },
      lumber: {
        name: 'Lumber Camp',
        baseCost: { gold: 40 },
        production: { wood: 1 },
        upgrades: [
          { cost: { gold: 150 }, mult: 2 },
          { cost: { gold: 500 }, mult: 3 },
          { cost: { gold: 2000 }, mult: 5 },
        ],
        unlockReq: { stone: 5 },
      },
      bakery: {
        name: 'Bakery',
        baseCost: { gold: 100, wheat: 20 },
        production: { gold: 3 },
        consumes: { wheat: 1 },
        upgrades: [
          { cost: { gold: 300 }, mult: 2 },
          { cost: { gold: 1000 }, mult: 3 },
          { cost: { gold: 4000 }, mult: 5 },
        ],
        unlockReq: { wheat: 30 },
      },
      blacksmith: {
        name: 'Blacksmith',
        baseCost: { gold: 200, stone: 30, wood: 20 },
        production: { gold: 8 },
        consumes: { stone: 1, wood: 1 },
        upgrades: [
          { cost: { gold: 600 }, mult: 2 },
          { cost: { gold: 2000 }, mult: 3 },
          { cost: { gold: 8000 }, mult: 5 },
        ],
        unlockReq: { stone: 50, wood: 30 },
      },
      market: {
        name: 'Market',
        baseCost: { gold: 500, wood: 50 },
        production: { gold: 15 },
        upgrades: [
          { cost: { gold: 1500 }, mult: 2 },
          { cost: { gold: 5000 }, mult: 3 },
          { cost: { gold: 20000 }, mult: 5 },
        ],
        unlockReq: { gold: 300 },
      },
      townhall: {
        name: 'Town Hall',
        baseCost: { gold: 2000, stone: 100, wood: 100 },
        production: { gold: 50 },
        upgrades: [
          { cost: { gold: 8000 }, mult: 2 },
          { cost: { gold: 30000 }, mult: 3 },
        ],
        unlockReq: { gold: 1000, stone: 80, wood: 80 },
      },
      barn: {
        name: 'Barn',
        baseCost: { gold: 75, wood: 15 },
        production: {},
        storageBonus: 100,
        upgrades: [
          { cost: { gold: 200 }, mult: 2 },
          { cost: { gold: 600 }, mult: 3 },
        ],
        unlockReq: { wood: 10 },
      },
    };

    // ==========================================
    // MILESTONE CONFIGURATION
    // ==========================================
    const MILESTONES = {
      first_farm: {
        name: "First Harvest",
        description: "Build your first Wheat Farm",
        condition: (res, bldgs) => countBuildings(bldgs, 'wheat_farm') >= 1,
        reward: { gold: 15 },
        icon: 'ğŸŒ±'
      },
      second_farm: {
        name: "Expanding Fields",
        description: "Build a second Wheat Farm",
        condition: (res, bldgs) => countBuildings(bldgs, 'wheat_farm') >= 2,
        reward: { gold: 10 },
        icon: 'ğŸŒ¾'
      },
      wheat_10: {
        name: "First Stockpile",
        description: "Accumulate 10 wheat",
        condition: (res, bldgs) => res.wheat >= 10,
        reward: { gold: 20 },
        icon: 'ğŸ“¦'
      },
      first_quarry: {
        name: "Breaking Ground",
        description: "Build a Stone Quarry",
        condition: (res, bldgs) => countBuildings(bldgs, 'quarry') >= 1,
        reward: { gold: 25 },
        icon: 'â›ï¸'
      },
      stone_5: {
        name: "Solid Foundation",
        description: "Accumulate 5 stone",
        condition: (res, bldgs) => res.stone >= 5,
        reward: { gold: 15 },
        icon: 'ğŸª¨'
      },
      first_lumber: {
        name: "Into the Woods",
        description: "Build a Lumber Camp",
        condition: (res, bldgs) => countBuildings(bldgs, 'lumber') >= 1,
        reward: { gold: 30 },
        icon: 'ğŸª“'
      },
      wheat_30: {
        name: "Bread Basket",
        description: "Accumulate 30 wheat",
        condition: (res, bldgs) => res.wheat >= 30,
        reward: { gold: 50 },
        icon: 'ğŸ§º'
      },
      first_bakery: {
        name: "Self-Sufficient!",
        description: "Build a Bakery and start producing gold",
        condition: (res, bldgs) => countBuildings(bldgs, 'bakery') >= 1,
        reward: { gold: 100 },
        icon: 'ğŸ¥–'
      }
    };

    // ==========================================
    // MERCHANT & MARKET CONFIGURATION
    // ==========================================
    const MERCHANT_CONFIG = {
      firstAppearDelay: 60000,      // 60 sec before first visit
      minInterval: 45000,           // Min time between visits
      maxInterval: 90000,           // Max time between visits
      visitDuration: 30000,         // How long merchant stays

      prices: {
        wheat: 2,
        stone: 3,
        wood: 3
      },

      maxPerVisit: {
        wheat: 20,
        stone: 15,
        wood: 15
      }
    };

    const MARKET_CONFIG = {
      prices: {
        wheat: 3,
        stone: 5,
        wood: 5
      }
      // No quantity limits for market
    };

    // Convert grid coordinates to screen position (isometric projection)
    // NOTE: Delegates to CoordinateService via global bridge
    function gridToScreen(gridX, gridY) {
      return window.gridToScreen ? window.gridToScreen(gridX, gridY) : { x: 0, y: 0, z: 0 };
    }

    // Cursor detection offsets (to align cursor with visual tile positions)
    let cursorOffsetX = -1;
    let cursorOffsetY = -1;

    // Convert screen (pixel) coordinates to grid coordinates
    // NOTE: Delegates to CoordinateService via global bridge
    // Returns { col, row } - may be fractional, use Math.floor for tile index
    function screenToGrid(screenX, screenY) {
      return window.screenToGrid ? window.screenToGrid(screenX, screenY) : { col: 0, row: 0 };
    }

    // Building footprint size (2x2 tiles)
    const BUILDING_FOOTPRINT = 2;

    // ==========================================
    // NEW BUILDING SYSTEM - Dynamic Placement
    // ==========================================
    // Buildings stored as array: { type, row, col, level }
    // Reference to GameStateService's buildings array (set by initStateReferences)
    let placedBuildings;

    // Get set of tile positions occupied by built buildings (uses local placedBuildings)
    // Delegates to BuildingService via global bridge
    function getOccupiedTiles() {
      if (window.getOccupiedTiles) {
        return window.getOccupiedTiles();
      }
      // Fallback: compute from shared placedBuildings
      const occupied = new Set();
      placedBuildings.forEach(building => {
        for (let dr = 0; dr < BUILDING_FOOTPRINT; dr++) {
          for (let dc = 0; dc < BUILDING_FOOTPRINT; dc++) {
            occupied.add(`${building.row + dr},${building.col + dc}`);
          }
        }
      });
      return occupied;
    }

    // Delegates to BuildingService via global bridge
    function canPlaceAt(row, col) {
      if (window.canPlaceAt) {
        return window.canPlaceAt(row, col);
      }
      // Fallback: local implementation
      const { rows, cols } = TILE_CONFIG;

      // Check bounds - building needs 2x2 space
      if (row < 0 || col < 0 || row + BUILDING_FOOTPRINT > rows || col + BUILDING_FOOTPRINT > cols) {
        return false;
      }

      // Check for collisions with existing buildings
      const occupied = getOccupiedTiles();
      for (let dr = 0; dr < BUILDING_FOOTPRINT; dr++) {
        for (let dc = 0; dc < BUILDING_FOOTPRINT; dc++) {
          if (occupied.has(`${row + dr},${col + dc}`)) {
            return false;
          }
        }
      }

      return true;
    }

    /* ========================================
     * LEGACY COMMENTED OUT - Now using BuildingService
     * ========================================
    // Place a building at the specified grid position
    function placeBuilding(type, row, col) {
      const def = BUILDINGS[type];
      if (!def) return false;

      // Check if we can afford it
      if (!canAfford(def.baseCost)) {
        notify(`Not enough resources to build ${def.name}!`, 'error');
        return false;
      }

      // Check if placement is valid
      if (!canPlaceAt(row, col)) {
        notify('Cannot place building here!', 'error');
        return false;
      }

      // Deduct cost
      Object.entries(def.baseCost).forEach(([res, amt]) => {
        resources[res] -= amt;
      });

      // Add building
      placedBuildings.push({
        type: type,
        row: row,
        col: col,
        level: 0
      });

      notify(`${def.name} built!`, 'success');

      // Check if this gold-producing building ends the stipend
      if (['bakery', 'blacksmith', 'market', 'townhall'].includes(type)) {
        checkStipendStatus();
      }

      // If Market is built, disable the traveling merchant
      if (type === 'market') {
        disableMerchant();
        notify('Market built! You now have permanent access to trading.', 'success');
      }

      // Check building milestones immediately
      checkMilestones();

      updateUI();
      return true;
    }
    * END LEGACY */

    // Slim delegation to BuildingService
    // Side effects (stipend check, merchant disable, milestones) handled via EventBus subscriptions
    function placeBuilding(type, row, col) {
      const result = window._buildingService.placeBuilding(type, row, col);
      if (result.success) {
        const def = BUILDINGS[type];
        notify(`${def.name} built!`, 'success');
        if (type === 'market') {
          notify('Market built! You now have permanent access to trading.', 'success');
        }

        // Remove tiles under the new building (2x2 footprint) to avoid stutter
        for (let dr = 0; dr < BUILDING_FOOTPRINT; dr++) {
          for (let dc = 0; dc < BUILDING_FOOTPRINT; dc++) {
            const tile = document.querySelector(`.tile[data-row="${row + dr}"][data-col="${col + dc}"]`);
            if (tile) tile.remove();
          }
        }

        // Render just the new building (it's the last one added)
        const buildings = window._gameState.getBuildings();
        const newBuildingIndex = buildings.length - 1;
        window._buildingRenderer.renderSingle(buildings[newBuildingIndex], newBuildingIndex);

        updateUI();  // Update resources/stats only (no full re-render)
      } else if (result.error) {
        notify(result.error, 'error');
      }
      return result.success;
    }

    // Expose placeBuilding for PlacementController
    window.placeBuilding = placeBuilding;

    // Find building at a specific grid position - delegates to BuildingService
    function getBuildingAt(row, col) {
      if (window.getBuildingAt) {
        return window.getBuildingAt(row, col);
      }
      // Fallback: local implementation
      return placedBuildings.find(b =>
        row >= b.row && row < b.row + BUILDING_FOOTPRINT &&
        col >= b.col && col < b.col + BUILDING_FOOTPRINT
      );
    }

    // Convert grid (row, col) to pixel position for buildings
    // NOTE: Delegates to CoordinateService via global bridge
    // isBuilt: true for constructed buildings (use debug offsets), false for placeholders (compact UI)
    function gridToPixel(row, col, isBuilt = false) {
      return window.gridToPixel ? window.gridToPixel(row, col, isBuilt) : { x: 0, y: 0, z: 0 };
    }

    // Old SLOTS system removed - buildings are now placed dynamically via placedBuildings[]

    // ==========================================
    // DEBUG OFFSETS (adjustable via sliders)
    // ==========================================
    let debugOffsetX = 2;
    let debugOffsetY = -8;
    let debugSizeMult = 2;

    // ==========================================
    // GAME STATE
    // ==========================================
    // Reference to GameStateService's resources object (set by initStateReferences)
    let resources;
    // Buildings are now tracked in placedBuildings[] array (defined in PLACEMENT section)

    /**
     * Initialize state references from GameStateService
     * Called after ES module loads but before init()
     * @returns {boolean} True if successful
     */
    function initStateReferences() {
      if (window._gameState) {
        placedBuildings = window._gameState.getBuildingsRef();
        resources = window._gameState.getResourcesRef();
        return true;
      }
      return false;
    }

    /* ========================================
     * LEGACY STATE - Now managed by services
     * These are kept for backwards compatibility with UI functions
     * Real state lives in GameStateService, accessed via:
     * - window._stipendService.getState()
     * - window._milestoneService.getCompletedMilestones()
     * - window._merchantService.getState()
     * ======================================== */

    // Royal Stipend state (LEGACY - use StipendService)
    let royalStipend = {
      active: true,           // Currently receiving stipend
      totalReceived: 0,       // Tracking for stats/achievements
      endReason: null         // 'bakery' | 'blacksmith' | 'market' | 'townhall'
    };

    // Milestone tracking (LEGACY - use MilestoneService)
    let completedMilestones = new Set();

    // Merchant state (LEGACY - use MerchantService)
    let merchant = {
      active: false,                // Is merchant currently visiting?
      visitStartTime: null,         // When current visit started
      soldThisVisit: {              // Track sales per visit for limits
        wheat: 0,
        stone: 0,
        wood: 0
      },
      nextVisitTime: null,          // Scheduled next arrival
      totalVisits: 0,               // Stats tracking
      disabled: false,              // True once Market is built
      visitTimeout: null,           // Reference to departure timeout
      nextVisitTimeout: null        // Reference to next visit timeout
    };

    let merchantTimerInterval = null;

    // ==========================================
    // HELPER FUNCTIONS
    // ==========================================
    // NOTE: These use shared state from GameStateService via getBuildingsRef()/getResourcesRef()
    // They could delegate to window.* service bridges but work fine with shared state

    // Delegates to ResourceService via global bridge
    function formatNumber(num) {
      return window.formatNumber ? window.formatNumber(num) : Math.floor(num).toString();
    }

    // Check if player can afford a cost - could use window.canAfford
    function canAfford(cost) {
      return window.canAfford ? window.canAfford(cost) : Object.entries(cost).every(([res, amt]) => resources[res] >= amt);
    }

    // Check if requirement is met - could use window.isUnlocked
    function isUnlocked(req) {
      return window.isUnlocked ? window.isUnlocked(req) : (!req || Object.entries(req).every(([res, amt]) => resources[res] >= amt));
    }

    // Spend resources - could use window.spendResources
    function spendResources(cost) {
      if (window.spendResources) {
        window.spendResources(cost);
      } else {
        Object.entries(cost).forEach(([res, amt]) => {
          resources[res] -= amt;
        });
      }
    }

    function notify(message, type = 'success') {
      const container = document.getElementById('notifications');
      const div = document.createElement('div');
      div.className = `notification ${type}`;
      div.textContent = message;
      container.appendChild(div);
      setTimeout(() => div.remove(), 3000);
    }

    // ==========================================
    // ROYAL STIPEND FUNCTIONS
    // ==========================================
    // Delegates to BuildingService via global bridge
    function hasGoldProduction() {
      if (window.hasGoldProduction) {
        return window.hasGoldProduction();
      }
      // Fallback: local implementation
      const goldProducers = ['bakery', 'blacksmith', 'market', 'townhall'];
      return placedBuildings.some((building) => goldProducers.includes(building.type));
    }

    /* ========================================
     * LEGACY COMMENTED OUT - StipendService handles via EventBus subscription
     * ========================================
    function checkStipendStatus() {
      if (!royalStipend.active) return;

      if (hasGoldProduction()) {
        royalStipend.active = false;
        // Find which building ended it (for flavor text)
        placedBuildings.forEach((building) => {
          if (['bakery', 'blacksmith', 'market', 'townhall'].includes(building.type)) {
            royalStipend.endReason = building.type;
          }
        });
        notify("The King's stipend has ended. You're self-sufficient now! ğŸ‘‘", 'success');
        updateStipendIndicator();
      }
    }
    * END LEGACY */

    // StipendService subscribes to BUILDING_PLACED event and auto-checks
    function checkStipendStatus() {
      // Handled by StipendService via EventBus subscription to BUILDING_PLACED
      // This function kept for backwards compatibility (may be called from old code)
      if (window._stipendService) {
        window._stipendService.checkStatus();
      }
    }

    /* ========================================
     * LEGACY COMMENTED OUT - StipendService handles via EventBus subscription
     * ========================================
    function stipendTick() {
      if (!royalStipend.active) return;

      resources.gold += 1;
      royalStipend.totalReceived += 1;
    }
    * END LEGACY */

    // Publish STIPEND_TICK event - StipendService handles the tick
    function stipendTick() {
      window._eventBus.publish(window._Events.STIPEND_TICK);
    }

    function updateStipendIndicator() {
      const indicator = document.getElementById('stipend-indicator');
      // Use service state if available
      const isActive = window._stipendService ? window._stipendService.isActive() : royalStipend.active;
      if (isActive) {
        indicator.classList.remove('inactive');
      } else {
        indicator.classList.add('inactive');
      }
    }

    // ==========================================
    // MILESTONE FUNCTIONS
    // ==========================================
    function countBuildings(bldgs, type) {
      return bldgs.filter((b) => b.type === type).length;
    }

    /* ========================================
     * LEGACY COMMENTED OUT - MilestoneService handles via EventBus subscription
     * ========================================
    function grantReward(reward) {
      Object.entries(reward).forEach(([res, amt]) => {
        resources[res] += amt;
      });
    }

    function checkMilestones() {
      let anyCompleted = false;

      Object.entries(MILESTONES).forEach(([id, milestone]) => {
        // Skip already completed
        if (completedMilestones.has(id)) return;

        // Check condition
        if (milestone.condition(resources, placedBuildings)) {
          completedMilestones.add(id);
          grantReward(milestone.reward);
          showMilestonePopup(milestone);
          anyCompleted = true;
        }
      });

      if (anyCompleted) {
        updateMilestonePanel();
      }
    }
    * END LEGACY */

    // MilestoneService subscribes to TICK and BUILDING_PLACED events
    function checkMilestones() {
      // Handled by MilestoneService via EventBus
      // This function kept for backwards compatibility
      if (window._milestoneService) {
        const completed = window._milestoneService.checkMilestones();
        // Show popup for each completed milestone
        completed.forEach(({ milestone }) => {
          showMilestonePopup(milestone);
        });
        if (completed.length > 0) {
          updateMilestonePanel();
        }
      }
    }

    function showMilestonePopup(milestone) {
      const rewardText = Object.entries(milestone.reward)
        .map(([res, amt]) => `+${amt} ${res === 'gold' ? 'ğŸ’°' : res === 'wheat' ? 'ğŸŒ¾' : res === 'stone' ? 'â›ï¸' : 'ğŸŒ²'}`)
        .join(' ');

      notify(`${milestone.icon} ${milestone.name}! ${rewardText}`, 'milestone');
    }

    function updateMilestonePanel() {
      const list = document.getElementById('milestone-list');
      const progress = document.getElementById('milestone-progress');

      // Use MilestoneService if available, fall back to legacy state
      const isCompleted = window._milestoneService
        ? (id) => window._milestoneService.isCompleted(id)
        : (id) => completedMilestones.has(id);
      const completedCount = window._milestoneService
        ? window._milestoneService.getCompletedCount()
        : completedMilestones.size;

      list.innerHTML = Object.entries(MILESTONES).map(([id, m]) => {
        const done = isCompleted(id);
        const rewardText = Object.entries(m.reward)
          .map(([r, a]) => `+${a}${r === 'gold' ? 'ğŸ’°' : ''}`)
          .join(' ');

        return `
          <div class="milestone-item ${done ? 'completed' : ''}">
            <span class="milestone-icon">${done ? 'âœ…' : m.icon}</span>
            <div class="milestone-info">
              <div class="milestone-name">${m.name}</div>
              <div class="milestone-desc">${m.description}</div>
            </div>
            <div class="milestone-reward">${rewardText}</div>
          </div>
        `;
      }).join('');

      progress.textContent = `${completedCount}/${Object.keys(MILESTONES).length}`;
    }

    let milestonePanelCollapsed = false;
    function toggleMilestonePanel() {
      const list = document.getElementById('milestone-list');
      milestonePanelCollapsed = !milestonePanelCollapsed;
      if (milestonePanelCollapsed) {
        list.classList.add('collapsed');
      } else {
        list.classList.remove('collapsed');
      }
    }

    // ==========================================
    // MERCHANT FUNCTIONS
    // ==========================================
    function randomBetween(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function capitalize(str) {
      return str.charAt(0).toUpperCase() + str.slice(1);
    }

    function scheduleMerchantVisit(isFirst = false) {
      if (merchant.disabled) return;

      // Clear any existing timeout
      if (merchant.nextVisitTimeout) {
        clearTimeout(merchant.nextVisitTimeout);
      }

      const delay = isFirst
        ? MERCHANT_CONFIG.firstAppearDelay
        : randomBetween(MERCHANT_CONFIG.minInterval, MERCHANT_CONFIG.maxInterval);

      merchant.nextVisitTime = Date.now() + delay;

      merchant.nextVisitTimeout = setTimeout(() => {
        if (!merchant.disabled) {
          merchantArrives();
        }
      }, delay);
    }

    function merchantArrives() {
      merchant.active = true;
      merchant.visitStartTime = Date.now();
      merchant.soldThisVisit = { wheat: 0, stone: 0, wood: 0 };
      merchant.totalVisits++;

      // Show merchant UI
      showMerchantBanner();
      notify('ğŸ§³ A traveling merchant has arrived!', 'merchant');

      // Start countdown timer
      startMerchantCountdown();

      // Schedule departure
      merchant.visitTimeout = setTimeout(() => {
        merchantDeparts();
      }, MERCHANT_CONFIG.visitDuration);
    }

    function merchantDeparts() {
      if (!merchant.active) return;

      merchant.active = false;
      hideMerchantBanner();
      closeMerchantPanel();
      stopMerchantCountdown();
      notify("ğŸ‘‹ The merchant has left. They'll return soon...", 'info');

      // Schedule next visit
      scheduleMerchantVisit();
    }

    function disableMerchant() {
      merchant.disabled = true;
      merchant.active = false;

      // Clear timeouts
      if (merchant.visitTimeout) {
        clearTimeout(merchant.visitTimeout);
      }
      if (merchant.nextVisitTimeout) {
        clearTimeout(merchant.nextVisitTimeout);
      }

      hideMerchantBanner();
      closeMerchantPanel();
      stopMerchantCountdown();
    }

    function showMerchantBanner() {
      document.getElementById('merchant-banner').classList.add('visible');
    }

    function hideMerchantBanner() {
      const banner = document.getElementById('merchant-banner');
      banner.classList.remove('visible');
      banner.classList.remove('urgent');
    }

    // NOTE: openMerchantPanel, closeMerchantPanel, renderMerchantTradeRows are now provided
    // by MerchantPanelController via global bridges.

    function startMerchantCountdown() {
      // Delegate to MerchantPanelController
      if (window._merchantPanelController) {
        window._merchantPanelController.startCountdown();
      }
    }

    function stopMerchantCountdown() {
      // Delegate to MerchantPanelController
      if (window._merchantPanelController) {
        window._merchantPanelController.stopCountdown();
      }
    }

    function sellToMerchant(resource, amount = 1) {
      if (!merchant.active) return false;

      const config = MERCHANT_CONFIG;
      const maxCanSell = config.maxPerVisit[resource] - merchant.soldThisVisit[resource];
      const actualAmount = Math.min(amount, maxCanSell, resources[resource]);

      if (actualAmount <= 0) {
        if (resources[resource] <= 0) {
          notify(`No ${resource} to sell!`, 'error');
        } else {
          notify(`Merchant won't buy more ${resource} this visit!`, 'error');
        }
        return false;
      }

      const goldEarned = actualAmount * config.prices[resource];

      resources[resource] -= actualAmount;
      resources.gold += goldEarned;
      merchant.soldThisVisit[resource] += actualAmount;

      notify(`Sold ${actualAmount} ${resource} for ${goldEarned} gold!`, 'success');
      updateUI();
      renderMerchantTradeRows();

      return true;
    }

    // ==========================================
    // MARKET TRADING FUNCTIONS
    // ==========================================
    function hasMarket() {
      return placedBuildings.some((building) => building.type === 'market');
    }

    function getMarketLevel() {
      const market = placedBuildings.find((b) => b.type === 'market');
      return market ? market.level + 1 : 0;
    }

    function sellAtMarket(resource, amount = 1) {
      if (!hasMarket()) return false;

      const actualAmount = Math.min(amount, resources[resource]);

      if (actualAmount <= 0) {
        notify(`No ${resource} to sell!`, 'error');
        return false;
      }

      // Market level boosts prices: +10% per upgrade level
      const levelBonus = 1 + (getMarketLevel() - 1) * 0.1;
      const basePrice = MARKET_CONFIG.prices[resource];
      const finalPrice = Math.floor(basePrice * levelBonus);
      const goldEarned = actualAmount * finalPrice;

      resources[resource] -= actualAmount;
      resources.gold += goldEarned;

      notify(`Sold ${actualAmount} ${resource} for ${goldEarned} gold!`, 'success');
      updateUI();
      updateMarketTradingPanel();

      return true;
    }

    function updateMarketTradingPanel() {
      const marketStatus = document.getElementById('market-status');
      const marketContent = document.getElementById('market-trading-content');

      if (!hasMarket()) {
        // Show locked message
        marketStatus.style.display = 'block';
        marketContent.style.display = 'none';
        return;
      }

      // Show trading UI
      marketStatus.style.display = 'none';
      marketContent.style.display = 'block';

      const level = getMarketLevel();
      const levelBonus = 1 + (level - 1) * 0.1;

      document.getElementById('market-level').textContent = level;

      const container = document.getElementById('market-trades');
      const resourceEmoji = { wheat: 'ğŸŒ¾', stone: 'â›ï¸', wood: 'ğŸŒ²' };

      container.innerHTML = ['wheat', 'stone', 'wood'].map(res => {
        const have = resources[res];
        const basePrice = MARKET_CONFIG.prices[res];
        const finalPrice = Math.floor(basePrice * levelBonus);

        return `
          <div class="market-row">
            <span class="market-res">${resourceEmoji[res]} ${have}</span>
            <span class="market-price">${finalPrice}ğŸ’°</span>
            <div class="market-btns">
              <button onclick="sellAtMarket('${res}', 1)" ${have < 1 ? 'disabled' : ''}>1</button>
              <button onclick="sellAtMarket('${res}', 10)" ${have < 10 ? 'disabled' : ''}>10</button>
              <button onclick="sellAtMarket('${res}', ${have})" ${have === 0 ? 'disabled' : ''}>All</button>
            </div>
          </div>
        `;
      }).join('');
    }

    // ==========================================
    // GAME LOGIC
    // ==========================================
    // NOTE: Delegates to ProductionService via global bridge
    function calculateProduction() {
      return window.calculateProduction ? window.calculateProduction() : { gold: 0, wheat: 0, stone: 0, wood: 0 };
    }

    /* ========================================
     * LEGACY COMMENTED OUT - Now using ProductionService via EventBus
     * ========================================
    function tick() {
      placedBuildings.forEach((building) => {
        const def = BUILDINGS[building.type];
        if (!def) return;

        const mult = building.level > 0 ? def.upgrades[building.level - 1].mult : 1;

        let canProduce = true;
        if (def.consumes) {
          canProduce = Object.entries(def.consumes).every(([res, amt]) => resources[res] >= amt);
          if (canProduce) {
            Object.entries(def.consumes).forEach(([res, amt]) => {
              resources[res] -= amt;
            });
          }
        }

        if (canProduce) {
          Object.entries(def.production).forEach(([res, amt]) => {
            resources[res] += amt * mult;
          });
        }
      });

      // Check resource-based milestones after production
      checkMilestones();

      updateUI();
    }
    * END LEGACY */

    // Slim tick() - publish TICK event, services handle production/milestones
    function tick() {
      // ProductionService and MilestoneService subscribe to TICK event
      window._eventBus.publish(window._Events.TICK);
      updateUI();
    }

    // Old buildOrUpgrade removed - now using placeBuilding() and upgradeBuilding()

    function resetGame() {
      resources = { gold: 50, wheat: 0, stone: 0, wood: 0 };
      placedBuildings = [];

      // Reset Royal Stipend
      royalStipend = { active: true, totalReceived: 0, endReason: null };
      updateStipendIndicator();

      // Reset Milestones
      completedMilestones = new Set();
      updateMilestonePanel();

      // Reset Merchant
      if (merchant.visitTimeout) clearTimeout(merchant.visitTimeout);
      if (merchant.nextVisitTimeout) clearTimeout(merchant.nextVisitTimeout);
      if (merchantTimerInterval) clearInterval(merchantTimerInterval);
      merchant = {
        active: false,
        visitStartTime: null,
        soldThisVisit: { wheat: 0, stone: 0, wood: 0 },
        nextVisitTime: null,
        totalVisits: 0,
        disabled: false,
        visitTimeout: null,
        nextVisitTimeout: null
      };
      hideMerchantBanner();
      closeMerchantPanel();
      scheduleMerchantVisit(true);

      // Reset Market Trading Panel
      updateMarketTradingPanel();

      notify('Game reset!');
      updateUI(true);  // Re-render buildings since all were cleared
    }

    // NOTE: toggleTiles, toggleDebugSliders, toggleDarkMode are now provided
    // by DebugController via global bridges.

    // ==========================================
    // UI RENDERING
    // ==========================================
    // NOTE: renderDebugGrid, renderTileGrid are provided by Phase 7 Renderers via global bridges.
    // renderBuildings uses placedBuildings which now references GameStateService's buildings array.

    /* ========================================
     * LEGACY COMMENTED OUT - Now using BuildingRenderer
     * ========================================
    // Render buildings (placedBuildings points to GameStateService._state.buildings)
    function renderBuildings() {
      console.log('[renderBuildings] Called with', placedBuildings.length, 'buildings');
      const world = document.getElementById('game-world');
      if (!world) {
        console.error('[renderBuildings] game-world not found!');
        return;
      }

      // Remove existing building elements
      world.querySelectorAll('.building-slot').forEach(el => el.remove());

      // Render each building
      placedBuildings.forEach((building, index) => {
        const def = BUILDINGS[building.type];
        const level = building.level + 1;
        const assetPath = ASSETS[building.type]?.[level];

        // Get position
        const pos = gridToPixel(building.row, building.col, true);

        // Create building slot
        const slot = document.createElement('div');
        slot.className = 'building-slot built';
        slot.style.cssText = `left:${pos.x}px; top:${pos.y}px; z-index:${pos.z};`;
        slot.dataset.index = index;

        // Create building content (sprite or emoji fallback)
        const content = document.createElement('div');
        content.className = 'building-content';

        if (assetPath) {
          const img = document.createElement('img');
          img.src = assetPath;
          img.alt = def.name;
          img.className = 'building-sprite';
          img.onerror = () => {
            // Fallback to emoji on load error
            img.remove();
            content.textContent = EMOJI_FALLBACKS[building.type];
            content.classList.add('emoji-fallback');
          };
          content.appendChild(img);
        } else {
          content.textContent = EMOJI_FALLBACKS[building.type];
          content.classList.add('emoji-fallback');
        }

        slot.appendChild(content);

        // Add level badge
        const badge = document.createElement('div');
        badge.className = 'level-badge';
        badge.textContent = level;
        slot.appendChild(badge);

        // Add event handlers
        slot.onclick = () => upgradeBuilding(index);
        slot.onmouseenter = () => showBuildingInfoForPlaced(index);
        slot.onmouseleave = () => hideBuildingInfo();

        world.appendChild(slot);
      });
    }

    // Override global bridge to use local implementation
    window.renderBuildings = renderBuildings;
    * END LEGACY */

    // renderBuildings now provided by BuildingRenderer via global bridge in main.js
    // No local override needed - uses window.renderBuildings from main.js

    /* ========================================
     * LEGACY COMMENTED OUT - Now using BuildingService
     * ========================================
    // Upgrade a placed building
    function upgradeBuilding(index) {
      const building = placedBuildings[index];
      if (!building) return;

      const def = BUILDINGS[building.type];

      // Check if max level
      if (building.level >= def.upgrades.length) {
        notify(`${def.name} is already at max level!`, 'info');
        return;
      }

      const upgradeCost = def.upgrades[building.level].cost;

      // Check if we can afford
      if (!canAfford(upgradeCost)) {
        notify(`Not enough resources to upgrade ${def.name}!`, 'error');
        return;
      }

      // Deduct cost
      Object.entries(upgradeCost).forEach(([res, amt]) => {
        resources[res] -= amt;
      });

      // Upgrade
      building.level++;
      notify(`${def.name} upgraded to level ${building.level + 1}!`, 'success');
      updateUI();
    }
    * END LEGACY */

    // Slim delegation to BuildingService
    function upgradeBuilding(index) {
      const result = window._buildingService.upgradeBuilding(index);
      if (result.success) {
        const building = window._buildingService.getBuildingByIndex(index);
        const def = BUILDINGS[building.type];
        notify(`${def.name} upgraded to level ${building.level + 1}!`, 'success');

        // Update just the level badge on this building (no full re-render to avoid stutter)
        const slots = document.querySelectorAll('.building-slot');
        if (slots[index]) {
          const badge = slots[index].querySelector('.level-badge');
          if (badge) {
            badge.textContent = building.level + 1;
          }
        }

        updateUI();  // Update resources/stats only (no building re-render)
      } else if (result.error) {
        notify(result.error, result.error.includes('max level') ? 'info' : 'error');
      }
    }

    /**
     * Update UI elements
     * @param {boolean} [renderBuildings=false] - Whether to re-render buildings (only needed when buildings change)
     */
    function updateUI(renderBuildings = false) {
      const production = calculateProduction();

      // Update resources (both original bar and in-canvas overlay)
      ['gold', 'wheat', 'stone', 'wood'].forEach(res => {
        const value = formatNumber(resources[res]);
        const rate = production[res];
        const rateText = (rate >= 0 ? '+' : '') + rate.toFixed(1) + '/s';
        const rateClass = `resource-rate ${rate > 0 ? 'positive' : rate < 0 ? 'negative' : 'neutral'}`;
        const overlayRateClass = `resource-overlay-rate ${rate > 0 ? 'positive' : rate < 0 ? 'negative' : 'neutral'}`;

        // Update original resource bar
        document.getElementById(`${res}-value`).textContent = value;
        const rateEl = document.getElementById(`${res}-rate`);
        rateEl.textContent = rateText;
        rateEl.className = rateClass;

        // Update in-canvas overlay
        const overlayValueEl = document.getElementById(`overlay-${res}-value`);
        const overlayRateEl = document.getElementById(`overlay-${res}-rate`);
        if (overlayValueEl) overlayValueEl.textContent = value;
        if (overlayRateEl) {
          overlayRateEl.textContent = rateText;
          overlayRateEl.className = overlayRateClass;
        }
      });

      // Update stats
      const builtCount = placedBuildings.length;
      const totalLevels = placedBuildings.reduce((sum, b) => sum + (b.level + 1), 0);
      const netWorth = Object.values(resources).reduce((a, b) => a + b, 0);

      document.getElementById('stat-buildings').textContent = builtCount;
      document.getElementById('stat-levels').textContent = totalLevels;
      document.getElementById('stat-worth').textContent = formatNumber(netWorth);

      // Only re-render tiles and buildings when buildings actually change
      // This prevents the visual "stutter" from clearing and recreating elements every tick
      if (renderBuildings) {
        window.renderTileGrid();
        window.renderBuildings();

        // Re-apply placement highlights if in placement mode (tiles were just recreated)
        if (window._placementController && window._placementController.isActive()) {
          const hoverPos = window._placementController.getHoverPosition();
          if (hoverPos.row !== null && hoverPos.col !== null) {
            window._placementController.showHighlightAt(hoverPos.row, hoverPos.col);
          }
        }
      }

      // Update market trading panel if visible
      updateMarketTradingPanel();
    }

    // ==========================================
    // TAB SWITCHING
    // ==========================================
    // NOTE: switchTab, switchLeftTab are now provided by TabController via global bridges.

    // ==========================================
    // PLACEMENT MODE & BUILD LIST (Dynamic Placement)
    // ==========================================
    // NOTE: selectBuildingForPlacement, cancelPlacement, renderBuildList are now provided
    // by PlacementController via global bridges.
    // placementMode state is managed internally by PlacementController.

    // Legacy placement mode reference (for backwards compatibility with mouse handlers)
    // The PlacementController manages the actual state, but we need local refs for event handlers
    function clearPlacementHighlights() {
      // Delegate to TileRenderer
      if (window._tileRenderer) {
        window._tileRenderer.clearHighlights();
      } else {
        document.querySelectorAll('.tile.highlighted-valid, .tile.highlighted-invalid').forEach(tile => {
          tile.classList.remove('highlighted-valid', 'highlighted-invalid');
        });
      }
    }

    // Setup mouse event listeners - delegates to PlacementController
    function setupPlacementListeners() {
      // PlacementController sets up its own listeners via setupListeners()
      // This is called from init() but the actual work is done by initializeUI()
    }

    // ==========================================
    // BUILDING INFO PANEL
    // ==========================================
    let hoveredBuildingIndex = null;

    // Show info for a placed building
    function showBuildingInfoForPlaced(index) {
      hoveredBuildingIndex = index;
      const building = placedBuildings[index];
      if (!building) return;

      const def = BUILDINGS[building.type];

      // Hide empty message, show content
      document.getElementById('building-info-empty').style.display = 'none';
      document.getElementById('building-info-content').style.display = 'block';

      // Set basic info
      document.getElementById('info-icon').textContent = EMOJI_FALLBACKS[building.type];
      document.getElementById('info-name').textContent = def.name;

      const level = building.level + 1;
      const maxLevel = def.upgrades.length + 1;
      document.getElementById('info-level').textContent = `Level ${level} / ${maxLevel}`;
      document.getElementById('info-status').textContent = 'Built';
      document.getElementById('info-status').className = 'info-stat-value positive';

      // Upgrade cost
      if (building.level < def.upgrades.length) {
        const upgradeCost = def.upgrades[building.level].cost;
        const costText = Object.entries(upgradeCost)
          .map(([r, a]) => `${a}${r === 'gold' ? 'ğŸ’°' : r === 'wheat' ? 'ğŸŒ¾' : r === 'stone' ? 'â›ï¸' : 'ğŸŒ²'}`)
          .join(' ');
        document.getElementById('info-upgrade-cost').textContent = costText;
        document.getElementById('info-upgrade-row').style.display = 'flex';
        document.querySelector('#info-upgrade-row .info-stat-label').textContent = 'Upgrade Cost';
      } else {
        document.getElementById('info-upgrade-row').style.display = 'none';
      }

      // Production info
      const mult = building.level > 0 ? def.upgrades[building.level - 1].mult : 1;
      let prodHTML = '';

      if (Object.keys(def.production).length > 0) {
        Object.entries(def.production).forEach(([res, amt]) => {
          const icon = res === 'gold' ? 'ğŸ’°' : res === 'wheat' ? 'ğŸŒ¾' : res === 'stone' ? 'â›ï¸' : 'ğŸŒ²';
          prodHTML += `<div class="info-stat-row">
            <span class="info-stat-label">${icon} ${res.charAt(0).toUpperCase() + res.slice(1)}</span>
            <span class="info-stat-value positive">+${amt * mult}/s</span>
          </div>`;
        });
      }

      if (def.consumes) {
        Object.entries(def.consumes).forEach(([res, amt]) => {
          const icon = res === 'gold' ? 'ğŸ’°' : res === 'wheat' ? 'ğŸŒ¾' : res === 'stone' ? 'â›ï¸' : 'ğŸŒ²';
          prodHTML += `<div class="info-stat-row">
            <span class="info-stat-label">${icon} ${res.charAt(0).toUpperCase() + res.slice(1)}</span>
            <span class="info-stat-value negative">-${amt}/s</span>
          </div>`;
        });
      }

      if (def.storageBonus) {
        const bonus = def.storageBonus * mult;
        prodHTML += `<div class="info-stat-row">
          <span class="info-stat-label">ğŸ“¦ Storage</span>
          <span class="info-stat-value positive">+${bonus}</span>
        </div>`;
      }

      document.getElementById('info-production-list').innerHTML = prodHTML || '<div class="info-stat-row"><span class="info-stat-label">No production</span></div>';
    }

    function hideBuildingInfo() {
      hoveredBuildingIndex = null;
      document.getElementById('building-info-empty').style.display = 'block';
      document.getElementById('building-info-content').style.display = 'none';
    }

    // Expose building interaction functions for BuildingRenderer callbacks
    window.upgradeBuilding = upgradeBuilding;
    window.showBuildingInfoForPlaced = showBuildingInfoForPlaced;
    window.hideBuildingInfo = hideBuildingInfo;

    // ==========================================
    // DEBUG SLIDER FUNCTIONS
    // ==========================================
    // NOTE: setupDebugSliders, copyDebugValues are now provided by DebugController.
    // The global bridge window.copyDebugValues calls debugController.copyValues().

    // ==========================================
    // INITIALIZATION
    // ==========================================
    function init() {
      window.renderDebugGrid();  // Show debug grid (remove when done designing)
      updateUI(true);  // Initial render - include tiles and buildings

      // Initialize stipend indicator
      updateStipendIndicator();

      // Initialize milestone panel
      updateMilestonePanel();

      // Initialize market trading panel (hidden until market built)
      updateMarketTradingPanel();

      // Schedule first merchant visit
      scheduleMerchantVisit(true);

      // Initialize UI controllers (PlacementController, DebugController, etc.)
      // This sets up event listeners and wires EventBus subscriptions
      if (window.initializeUI) {
        window.initializeUI();
      }

      // Subscribe to service events for UI updates
      if (window._eventBus && window._Events) {
        // Show milestone popup when MilestoneService completes a milestone
        window._eventBus.subscribe(window._Events.MILESTONE_COMPLETED, (data) => {
          showMilestonePopup(data.milestone);
          updateMilestonePanel();
        });

        // Update stipend indicator when stipend ends
        window._eventBus.subscribe(window._Events.STIPEND_ENDED, (data) => {
          notify("The King's stipend has ended. You're self-sufficient now! ğŸ‘‘", 'success');
          updateStipendIndicator();
        });
      }

      // Start game tick (1 second)
      setInterval(tick, 1000);

      // Start stipend tick (2 seconds) - faster than main tick for responsiveness
      setInterval(stipendTick, 2000);
    }

    // Wait for ES module to be ready before initializing
    // ES modules load asynchronously, so window.initializeUI may not exist yet
    let waitAttempts = 0;
    function waitForModuleAndInit() {
      waitAttempts++;
      // Check both module loaded AND state refs can be initialized
      if (window.initializeUI && initStateReferences()) {
        console.log('[Init] Module loaded after ' + waitAttempts + ' attempts, calling init()');
        try {
          init();
          console.log('[Init] init() completed successfully');
        } catch (e) {
          console.error('[Init] Error in init():', e);
        }
      } else if (waitAttempts < 500) {
        // Module not loaded yet, wait and retry (max 5 seconds)
        setTimeout(waitForModuleAndInit, 10);
      } else {
        console.error('[Init] Module failed to load after 5 seconds. Check for import errors in browser console.');
      }
    }

    waitForModuleAndInit();
  </script>
</body>
</html>
